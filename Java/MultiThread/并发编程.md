## 并发编程

　　出现了某个方法论或者某个技术,一定是为了解决遇到了痛点,所以在了解并发编程的过程中,需要先了解并发编程解决的什么痛点.
　　互联网业务发展初期,整体业务的并发量还不够大,单单借助数据库与 Tomcat 这样的中间件,就可以解决并发问题.因此我们还不需要关心并发问题.
　　但是随着现在的整体业务规模越来越大,并发越来越大,而且多核服务器(32核/64核)的价格也不再高高在上,被很多互联网厂商使用,导致中间件以及数据库的并发支撑无法满足我们的要求,反而成为了我们的瓶颈.这样就是的 **并发编程** 又重新引起了人们的重视,并成为高端开发人员的一项必备技能.  
　　并发编程可以总结为三个核心问题: **分工** **同步** **互斥**  
　　**分工**: 如何高效的拆解任务并分配给线程,如 Fork/Join 框架  
　　**同步**: 线程之间如何协作,如 CountDownLatch   
　　**互斥**: 保证同一时刻只允许一个线程访问贡献资源,如 可重入锁  

### 安全性
　　**互斥** 是解决线程安全的核心方案

**并发编程 Bug 的源头**  
1. 缓存导致的可见性问题  
一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为 **可见性**  
2. 线程切换到来的原子性问题  
我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性为 **原子性**  
3. 编译优化带来的有序性问题  
一段程序代码执行顺序,需要按照顺序执行,不能被打乱 我理解为 **有序性**  

　　上述场景源头简单概括出现原因是, **缓存** 导致的可见性问题, **线程切换** 带来了原子性问题, **编译优化** 引起的有序性问题  
　　缓存,线程切换,编译优化其实与并发编程的目的一致,都是为了提高程序性能. 但是技术在解决一个问题的通时,必然会带来另外的一个问题,因此在 **采用一项技术的同时,一定要清楚它带来的问题是什么,以及如何规避** .

#### 原子性如何解决  
- **互斥锁(悲观锁)**  
  - **Java 语言提供的锁技术: synchronized**
  - **细粒度锁**
- **CAS(乐观锁)**
  - **Java 语言提供的 Atomic 类**
  - **CAS原则**   [Java：CAS(乐观锁)](https://www.jianshu.com/p/ae25eb3cfb5d)

### 活跃性  
  **互斥锁** 解决并发问题的核心工具,但是会带来死锁的问题
- **死锁了怎么办**  


### 性能  
